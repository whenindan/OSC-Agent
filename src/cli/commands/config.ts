import { Command } from 'commander';
import fs from 'fs';
import path from 'path';
import chalk from 'chalk';
import { promptForConfig } from '../prompts';
import { ConfigValidator } from '../config-validator';
import { loadConfig } from '../../config/loader';
import { Config } from '../../config/types';
import { logger } from '../../utils/logger';
import { metrics } from '../../utils/metrics';

export function registerConfigCommand(program: Command): void {
  const configCommand = program.command('config').description('Manage configuration');

  configCommand
    .command('init')
    .description('Initialize configuration interactively')
    .action(async () => {
      const startTimer = metrics.startTimer();
      try {
        logger.info(chalk.blue('Initializing configuration interactively...'));
        const config = await promptForConfig();
        logger.debug('Configuration received from prompt');

        const validation = ConfigValidator.validate(config);
        if (!validation.valid) {
          logger.warn(chalk.red('✗ Configuration is invalid based on your input:'));
          validation.errors?.forEach((e) => logger.warn(chalk.red(`  - ${e}`)));
          logger.warn('Interactive configuration invalid', { errors: validation.errors });
          metrics.record('command_duration', startTimer(), { command: 'config:init', status: 'invalid' });
          return;
        }

        let envContent = '# Generated by OSC Agent\n';
        if (config.github?.token) {
          envContent += `GITHUB_TOKEN=${config.github.token}\n`;
        }
        if (config.gemini?.api_key) {
          envContent += `GEMINI_API_KEY=${config.gemini.api_key}\n`;
        }
        if (config.gemini?.model_tier) {
          envContent += `GEMINI_MODEL_TIER=${config.gemini.model_tier}\n`;
        }
        if (config.e2b?.api_key) {
          envContent += `E2B_API_KEY=${config.e2b.api_key}\n`;
        }

        const targetPath = path.join(process.cwd(), '.env');
        if (fs.existsSync(targetPath)) {
          logger.warn(chalk.yellow('.env file already exists. Overwriting...'));
        }

        fs.writeFileSync(targetPath, envContent);
        logger.info(chalk.green(`Configuration saved to ${targetPath}`));

        const duration = startTimer();
        metrics.record('command_duration', duration, { command: 'config:init' });
      } catch (error) {
        logger.error('Configuration initialization failed', { error });
        throw error;
      }
    });

  configCommand
    .command('validate')
    .description('Validate current configuration')
    .action(async () => {
      const endTimer = metrics.startTimer();
      try {
        const config = loadConfig();
        logger.info('Validating configuration...');
        const validation = ConfigValidator.validate(config);

        if (validation.valid) {
          logger.info(chalk.green('✓ Configuration structure is valid.'));
        } else {
          logger.error(chalk.red('✗ Configuration structure is invalid:'));
          validation.errors?.forEach((e) => logger.error(chalk.red(`  - ${e}`)));
          const duration = endTimer();
          metrics.record('command_duration', duration, { command: 'config:validate', status: 'invalid_structure' });
          return;
        }

        logger.info('Testing connections...');
        await ConfigValidator.testConnections(config);

        const duration = endTimer();
        metrics.record('command_duration', duration, { command: 'config:validate', status: 'success' });
      } catch (error) {
        logger.error(chalk.red('Failed to load configuration.'));
        if (error instanceof Error) {
          logger.error(chalk.red(`  ${error.message}`));
        }
        const duration = endTimer();
        metrics.record('command_duration', duration, { command: 'config:validate', status: 'failed' });
      }
    });

  configCommand
    .command('show')
    .description('Show current configuration')
    .action(() => {
      try {
        const config = loadConfig();
        logger.info('Showing configuration...');
        // Mask secrets
        const maskedConfig = JSON.parse(JSON.stringify(config)) as Config;
        if (maskedConfig.github?.token) maskedConfig.github.token = '********';
        if (maskedConfig.gemini?.api_key) maskedConfig.gemini.api_key = '********';
        if (maskedConfig.e2b?.api_key) maskedConfig.e2b.api_key = '********';

        // For JSON output, we might strictly want to use console.log if piping is expected,
        // but for "showing", logger.info is safer per user instruction.
        // Using JSON.stringify with null, 2 for pretty print.
        logger.info(JSON.stringify(maskedConfig, null, 2));
      } catch (error) {
        logger.error(chalk.red('Failed to load configuration.'));
        if (error instanceof Error) {
          logger.error(chalk.red(error.message));
        }
      }
    });
}
